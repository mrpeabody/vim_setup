" Make Vim more useful
set nocompatible

filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle, required
Plugin 'gmarik/Vundle.vim'
Plugin 'Valloric/YouCompleteMe'
Plugin 'scrooloose/nerdtree'
Plugin 'Xuyuanp/nerdtree-git-plugin'
Plugin 'tpope/vim-fugitive'
Plugin 'marijnh/tern_for_vim'
Plugin 'hynek/vim-python-pep8-indent'
Plugin 'tell-k/vim-autopep8'
Plugin 'jiangmiao/auto-pairs'
Plugin 'sheerun/vim-polyglot'
Plugin 'othree/javascript-libraries-syntax.vim'
Plugin 'othree/jsdoc-syntax.vim'
Plugin 'othree/jspc.vim'
Plugin 'othree/csscomplete.vim'
Plugin 'othree/yajs.vim'
Plugin 'chrisbra/colorizer'
Plugin 'maksimr/vim-jsbeautify'
Plugin 'alvan/vim-closetag'
Plugin 'Valloric/MatchTagAlways'
Plugin 'heavenshell/vim-jsdoc'
Plugin 'lepture/vim-jinja'
Plugin 'SirVer/ultisnips'
Plugin 'lfilho/cosco.vim'
Plugin 'tmhedberg/SimpylFold'
Plugin 'nelstrom/vim-markdown-folding'
Plugin 'Yggdroot/indentLine'
Plugin 'terryma/vim-multiple-cursors'
Plugin 'nacitar/a.vim'
Plugin 'rdolgushin/gitignore.vim'
Plugin 'matze/vim-move'
" state autosave (uncomment to use IDE-like saved state for files - folds/cursor position, etc)
" Plugin 'restore_view.vim'
Plugin 'vim-scripts/vim-auto-save'
Plugin 'tpope/vim-commentary'

" Snippets are separated from the engine. Add this if you want them:
Plugin 'honza/vim-snippets'
Plugin 'airblade/vim-gitgutter'
Plugin 'severin-lemaignan/vim-minimap'
Plugin 'tpope/vim-surround'
Plugin 'foosoft/vim-argwrap'
Plugin 'itchyny/lightline.vim'
Plugin 'ryanoasis/vim-devicons'

" All of your Plugins must be added before the following line
call vundle#end()            " required

filetype plugin indent on    " required

" Multiple cursors setup
set lazyredraw
nnoremap <silent> <C-g> :MultipleCursorsFind <C-R>/<CR>
vnoremap <silent> <C-g> :MultipleCursorsFind <C-R>/<CR>

function Multiple_cursors_before()
    call youcompleteme#DisableCursorMovedAutocommands()
    let s:old_ycm_whitelist = g:ycm_filetype_whitelist
    let g:ycm_filetype_whitelist = {}
endfunction

function Multiple_cursors_after()
    call youcompleteme#EnableCursorMovedAutocommands()
    let g:ycm_filetype_whitelist = s:old_ycm_whitelist
endfunction

" make YCM compatible with UltiSnips
let g:ycm_key_list_select_completion=[]
let g:ycm_key_list_previous_completion=[]

" better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger='<tab>'
let g:UltiSnipsJumpForwardTrigger='<tab>'
let g:UltiSnipsJumpBackwardTrigger='<s-tab>'
let g:UltiSnipsListSnippets = '<c-b>'
let g:UltiSnipsSnippetsDir=expand("~/.vim/CustomSnippets")
let g:UltiSnipsSnippetDirectories=["CustomSnippets", "UltiSnips"]

let g:autopep8_max_line_length=120
let g:autopep8_disable_show_diff=1
let g:polyglot_disabled = ['markdown', 'javascript']
let g:vim_json_syntax_conceal = 0
let g:javascript_plugin_flow = 1

" Semicolon/Comma automatization
autocmd FileType javascript,css,c,cpp,java,cs nmap <silent> <Leader>; :CommaOrSemiColon<CR>
autocmd FileType javascript,css,c,cpp,java,cs imap <silent> <Leader>; <c-o>:CommaOrSemiColon<CR>

" Autocomplete 
set completeopt=longest,menuone
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
            \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

inoremap <expr> <M-,> pumvisible() ? '<C-n>' :
            \ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm set ft=jinja
autocmd FileType css,less setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown,jinja setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
inoremap <C-Space> <C-x><C-o>
inoremap <C-@> <C-Space>

let g:ycm_autoclose_preview_window_after_completion=1
let g:ycm_confirm_extra_conf=0
let g:airline_powerline_fonts = 1
let g:used_javascript_libs = 'jquery,react'
let g:AutoPairsUseInsertedCount = 1

" JsBeautify bindings
autocmd FileType javascript noremap <buffer> <F9> :call JsBeautify()<cr>
autocmd FileType json noremap <buffer> <F9> :call JsonBeautify()<cr>
autocmd FileType jsx noremap <buffer> <F9> :call JsxBeautify()<cr>
autocmd FileType html noremap <buffer> <F9> :call HtmlBeautify()<cr>
autocmd FileType css noremap <buffer> <F9> :call CSSBeautify()<cr>
autocmd FileType javascript vnoremap <buffer>  <c-f> :call RangeJsBeautify()<cr>
autocmd FileType json vnoremap <buffer> <c-f> :call RangeJsonBeautify()<cr>
autocmd FileType jsx vnoremap <buffer> <c-f> :call RangeJsxBeautify()<cr>
autocmd FileType html vnoremap <buffer> <c-f> :call RangeHtmlBeautify()<cr>

" Use the OS clipboard by default (on versions compiled with `+clipboard`)
if (executable('pbcopy') || executable('xclip') || executable('xsel')) && has('clipboard')
  set clipboard=unnamed
endif

" Enhance command-line completion
set wildmenu

" Allow cursor keys in insertode
set esckeys

" Allow backspace in insert mode
set backspace=indent,eol,start

" vim indentation settings
set autoindent

" Highlight matching parenthesis/braces by default
set showmatch

" Optimize for fast terminal connections
set ttyfast

" Add the g flag to search/replace by default
set gdefault

" Use UTF-8 without BOM
set encoding=utf-8

" Change mapleader
let mapleader=","

" Don’t add empty newlines at the end of files
" set binary
" set noeol

" Splits config
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
set splitbelow
set splitright

" reduces splits to a single line 
set wmh=0

" resize current buffer by +/- 5 
nnoremap <silent> _ :vertical resize -5<cr>
nnoremap <silent> + :vertical resize +5<cr>
nnoremap <silent> - :resize +5<cr>

" Hit f3 in order to have a 'normal' paste in the insert mode
set pastetoggle=<F3>

" Disable arrow keys in both insert and normal mode
nnoremap <Up> <NOP>
nnoremap <Down> <NOP>
nnoremap <Left> <NOP>
nnoremap <Right> <NOP>
inoremap <Up> <NOP>
inoremap <Down> <NOP>
inoremap <Left> <NOP>
inoremap <Right> <NOP>

" Disable mouse scroll
nmap <ScrollWheelUp> <nop>
nmap <S-ScrollWheelUp> <nop>
nmap <C-ScrollWheelUp> <nop>
nmap <ScrollWheelDown> <nop>
nmap <S-ScrollWheelDown> <nop>
nmap <C-ScrollWheelDown> <nop>
nmap <ScrollWheelLeft> <nop>
nmap <S-ScrollWheelLeft> <nop>
nmap <C-ScrollWheelLeft> <nop>
nmap <ScrollWheelRight> <nop>
nmap <S-ScrollWheelRight> <nop>
nmap <C-ScrollWheelRight> <nop>

" Enable per-directory .vimrc files and disable unsafe commands in them
set exrc
set secure

" Enable syntax highlighting
syntax on

" Color scheme
set background=dark
set t_Co=256
colorscheme OceanicNext
" Other options already installed: 
" wombat256mod, hybrid, predawn, zenburn, happy_hacking, monokai, amcolors, lucario, stereokai, onedark, py-darcula,
" xcode-default
" in case of onedark, uncomment the following line
" let g:onedark_termcolors=256
set colorcolumn=121
set wrap linebreak nolist
if (has("termguicolors"))
   set termguicolors
endif

 " enable italics, disabled by default
let g:oceanic_next_terminal_italic = 1

" enable bold, disabled by default
let g:oceanic_next_terminal_bold = 1

" Showing 120 symbols ruler
highlight ColorColumn ctermbg=236

" Highlight current line
set cursorline

" Make tabs as wide as four spaces
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set bs=2

" Enable line numbers
set number

" Highlight searches
set hlsearch

" When highlighting search terms, make sure text is contrasting color
highlight Search ctermbg=yellow ctermfg=black

" Do the same for gvim
highlight Search guibg=yellow guifg=black"
nnoremap <CR> :nohlsearch<CR>/<BS>

" Auto pairs setup
let g:AutoPairsFlyMode = 0

" Ignore case of searches
set ignorecase

" Highlight dynamically as pattern is typed
set incsearch

" Always show status line
set laststatus=2

" Respect modeline in files
set modeline
set modelines=4

" Enable mouse in all modes
set mouse=a

" Disable error bells
set noerrorbells

" Don’t reset cursor to start of line when moving around.
set nostartofline

" Show the cursor position
set ruler

" Don’t show the intro message when starting Vim
set shortmess=atI

" Show the current mode
set showmode

" Show the filename in the window titlebar
set title

" Show the (partial) command as it’s being typed
set showcmd

" Start scrolling three lines before the horizontal window border
set scrolloff=3


" Strip trailing whitespace (,ss)
function! StripWhitespace()
    let save_cursor = getpos(".")
    let old_query = getreg('/')
    :%s/\s\+$//e
    call setpos('.', save_cursor)
    call setreg('/', old_query)
endfunction
noremap <leader>ss :call StripWhitespace()<CR>


" Save a file as root (,W)
noremap <leader>W :w !sudo tee % > /dev/null<CR>


" Automatic commands
set timeoutlen=1000 ttimeoutlen=0
noremap % v%
nnoremap <silent> <F6> :!clear;python3 %<CR>
nnoremap <silent> <F5> :!clear;python %<CR>


" Minimap settings
let g:minimap_highlight='Visual'
" autocmd! VimEnter * Minimap
map <silent> <Leader>m  :MinimapToggle<CR>


" Filesystem Tree
" autocmd vimenter * NERDTree
" autocmd VimEnter * wincmd p
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
map <silent> <Leader>n  :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
let g:NERDTreeIndicatorMapCustom = {
            \ "Modified"  : "✹",
            \ "Staged"    : "✚",
            \ "Untracked" : "✭",
            \ "Renamed"   : "➜",
            \ "Unmerged"  : "═",
            \ "Deleted"   : "✖",
            \ "Dirty"     : "✗",
            \ "Clean"     : "✔︎",
            \ "Unknown"   : "?"
            \}
let NERDTreeIgnore = ['\.pyc$']


" Disable autocommenting
autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o


" Tabs
nnoremap th  :tabfirst<CR>
nnoremap tj  :tabnext<CR>
nnoremap tk  :tabprev<CR>
nnoremap tl  :tablast<CR>
nnoremap tt  :tabedit<Space>
nnoremap tn  :tabnext<Space>
nnoremap tm  :tabm<Space>
nnoremap td  :tabclose<CR>


" Set up the best markdown flavor as the default one
autocmd BufNewFile,BufFilePre,BufRead *.md set filetype=markdown.pandoc


" fix for very large screens (can't see the cursor)
if has('mouse_sgr')
    set ttymouse=sgr
endif


" Disable Macro recorder
map q <Nop>


" Special filetype settings for JSON
au FileType json setl ts=2 sts=2 et shiftwidth=2


" Map uppercase commands as well as lowercase
command WQ wq
command Wq wq
command W w
command Q q


" Folding settings
if &diff
    set foldmethod=diff
    highlight! link DiffText MatchParen
else
    set foldmethod=syntax
    autocmd BufWinEnter * silent! :%foldopen!
    autocmd WinEnter * setlocal foldmethod=syntax
    autocmd WinLeave * setlocal foldmethod=manual
endif

nnoremap <silent> <Space> @=(foldlevel('.')?'za':"\<Space>")<CR>
vnoremap <Space> zf
let g:SimpylFold_docstring_preview = 1

" .swp files location
set directory=$HOME/.vim/swapfiles//


" state autosave (uncomment to use IDE-like saved state for files - folds/cursor position, etc)
" set viewoptions=cursor,folds,slash,unix
" let g:skipview_files = ['*\.vim']


" Autosave settings
let g:auto_save = 0
let g:auto_save_in_insert_mode = 0


" Use VIM as a MAN page viewer
let $PAGER=''


" indentation guide character
let g:indentLine_char = '┆'

" colorize CSS
"let g:colorizer_auto_color = 1
let g:colorizer_auto_filetype='css,html,jinja,javascript'

" Arguments/lists/dicts inline/per line
nnoremap <silent> <leader>a :ArgWrap<CR>

" Bottom line settings (Lightline plugin)
let g:lightline = {
      \ 'mode_map': { 'c': 'NORMAL' },
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
      \ 'right': [ ['lineinfo'], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
      \ },
      \   'component': {
      \     'lineinfo': '⭡ %3l:%-2v', 'line': '%l', 'column': '%c', 'close': '%999X X '
      \   },
      \ 'component_function': {
      \   'modified': 'LightLineModified',
      \   'readonly': 'LightLineReadonly',
      \   'fugitive': 'LightLineFugitive',
      \   'filename': 'LightLineFilename',
      \   'fileformat': 'LightLineFileformat',
      \   'filetype': 'LightLineFiletype',
      \   'fileencoding': 'LightLineFileencoding',
      \   'mode': 'LightLineMode',
      \ },
      \ 'separator': { 'left': "\u2b80", 'right': "\u2b82" },
      \ 'subseparator': { 'left': "\u2b81", 'right': "\u2b83" }
      \ }

" \ 'component': { 'lineinfo': '\u2b61 %3l:%-2v' },

function! LightLineModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightLineReadonly()
  return &readonly ? '⭤' : ''
endfunction

function! LightLineFilename()
  return ('' != LightLineReadonly() ? LightLineReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
        \  &ft == 'unite' ? unite#get_status_string() :
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
        \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

function! LightLineFugitive()
  if &ft !~? 'vimfiler\|gundo' && exists("*fugitive#head")
    let branch = fugitive#head()
    let gitStats = GitGutterGetHunkSummary()
    return branch !=# '' ? '+'.gitStats[0].' ~'.gitStats[1].' -'.gitStats[2].' ⭠ '.branch : ''
  endif
  return ''
endfunction

function! LightLineFileformat()
  return winwidth(0) > 70 ? WebDevIconsGetFileFormatSymbol(): ''
endfunction

function! LightLineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? WebDevIconsGetFileTypeSymbol().' '.&filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
  return winwidth(0) > 60 ? lightline#mode() : ''
endfunction
" Uncomment the following text if no patched font is included
" let g:lightline = {
"       \ 'active': {
"       \   'left': [ [ 'mode', 'paste' ],
"       \             [ 'fugitive', 'readonly', 'filename', 'modified' ] ]
"       \ },
"       \ 'component': {
"       \   'readonly': '%{&filetype=="help"?"":&readonly?"⭤":""}',
"       \   'modified': '%{&filetype=="help"?"":&modified?"+":&modifiable?"":"-"}',
"       \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
"       \ },
"       \ 'component_visible_condition': {
"       \   'readonly': '(&filetype!="help"&& &readonly)',
"       \   'modified': '(&filetype!="help"&&(&modified||!&modifiable))',
"       \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
"       \ },
"       \ 'separator': { 'left': '', 'right': '' },
"       \ 'subseparator': { 'left': '|', 'right': '|' }
"       \ }

"set noshowmode


" Tab title improvements
set tabline=%!MyTabLine()  " custom tab pages line
function MyTabLine()
	let s = '' " complete tabline goes here
	" loop through each tab page
	for t in range(tabpagenr('$'))
		" set highlight
		if t + 1 == tabpagenr()
			let s .= '%#TabLineSel#'
		else
			let s .= '%#TabLine#'
		endif
		" set the tab page number (for mouse clicks)
		let s .= '%' . (t + 1) . 'T'
		let s .= ' '
		" set page number string
		let s .= t + 1 . ' '
		" get buffer names and statuses
		let n = ''      "temp string for buffer names while we loop and check buftype
		let m = 0       " &modified counter
		let bc = len(tabpagebuflist(t + 1))     "counter to avoid last ' '
		" loop through each buffer in a tab
		for b in tabpagebuflist(t + 1)
			" buffer types: quickfix gets a [Q], help gets [H]{base fname}
			" others get 1dir/2dir/3dir/fname shortened to 1/2/3/fname
			if getbufvar( b, "&buftype" ) == 'help'
				let n .= '[H]' . fnamemodify( bufname(b), ':t:s/.txt$//' )
			elseif getbufvar( b, "&buftype" ) == 'quickfix'
				let n .= '[Q]'
			else
				let n .= pathshorten(bufname(b))
			endif
			" check and ++ tab's &modified count
			if getbufvar( b, "&modified" )
				let m += 1
			endif
			" no final ' ' added...formatting looks better done later
			if bc > 1
				let n .= ' '
			endif
			let bc -= 1
		endfor
		" add modified label [n+] where n pages in tab are modified
		if m > 0
			let s .= '[' . m . '+]'
		endif
		" select the highlighting for the buffer names
		" my default highlighting only underlines the active tab
		" buffer names.
		if t + 1 == tabpagenr()
			let s .= '%#TabLineSel#'
		else
			let s .= '%#TabLine#'
		endif
		" add buffer names
		if n == ''
			let s.= '[New]'
		else
			let s .= n
		endif
		" switch to no underlining and add final space to buffer list
		let s .= ' '
	endfor
	" after the last tab fill with TabLineFill and reset tab page nr
	let s .= '%#TabLineFill#%T'
	" right-align the label to close the current tab page
	if tabpagenr('$') > 1
		let s .= '%=%#TabLineFill#%999Xclose'
	endif
	return s
endfunction


" Devicons settings
let g:WebDevIconsUnicodeDecorateFolderNodes = 1


" Line move plugin
let g:move_key_modifier = 'C'
